

# one:API接口文档

## 一：API V1接口说明

- 接口基准地址：http://127.0.0.1:3000/api
- 服务端已开启CORS跨域支持
- API认证统一使用的Token认证
- 需要授权的API，必须在请求头中使用authorization字段提供token令牌
- 使用HTTP Status Code 标识状态
- 数据返回格式统一使用JSON

## 1.1支持请求的方法：

GET:（select）从服务器取出一个资源

POST（create）：在服务器新建一个资源

PUT（update）：在服务器更新资源（客户端提供改变后的完整资源）

PATCH（update）:在服务器更新资源（客户端提供改变的属性）

DELETE（delete）：从服务器删除资源

HEAD：获取资源的元数据

OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的

## 1.2：通用返回状态说明

| 状态码 | 含义                  | 说明                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 200    | OK                    | 请求成功                                                     |
| 201    | created               | 创建成功                                                     |
| 204    | deleted               | 删除成功                                                     |
| 400    | bad request           | 请求地址不存在或者包含不支持的参数（语义有误，当前请求无法被服务器理解请求参数有误） |
| 401    | unauthorized          | 未授权，当前请求需要用户验证                                 |
| 403    | forbidden             | 禁止访问                                                     |
| 404    | Not Found             | 找不到资源                                                   |
| 301    | Found                 | 永久重定向（配合Location浏览器自动处理）                     |
| 302    |                       | 临时重定向（配合Location浏览器自动处理）                     |
| 304    | Not Modified          | 资源未被修改                                                 |
| 500    | Internal Server Error | 内部服务器错误（请求错误，设置错误，服务器本身问题）         |
| 502    | Bad Gayway            | 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 |
| 504    | Gaywey Timeout        | 当服务器作为网关，不能及时得到响应时返回此错误代码           |

分类描述 

1       信息，服务器收到请求，需要请求者`继续`执行操作

2           成功，操作被成功接收并处理**

3          重定向，需要进一步的操作以完成请求**

4        `客户端错误`，请求包含语法错误或无法完成请求**

5         `服务器错误`，服务器处理请求的过程中发生了错误

## 1.3 什么是 Restful-API

Restful-API: 一种新的`API设计方法`。

- 把每个URI当做`一个资源`
- 不使用url参数
- 传统API设计: /api/list?pageIndex=2
- **Restful**-API设计: /api/list/2

## 1.4  vuex原理

![image-20230720151702238](C:\Users\lemon\AppData\Roaming\Typora\typora-user-images\image-20230720151702238.png)



# two:Promise

promise 承上启下   

承上----是对回调函数知道，产生回调地狱

启下 ----- 

#### **解决异步回调问题**

 构造函数   resolve 成功；reject 失败

三大状态： --- pending  ---fulfilled  ----rejected  （状态只能更改一次）

promise 实例化对象的状态只能从**pending到fulfilled**

或者是**pending到rejected**，**不能从fulfilled到rejected**

或者反之都不行

```
then:指定用于得到成功value的成功回调和用于得到失败reason的失败回调，并且将返回一个新的promise实例化对象
	成功的状态：执行then方法的第一个回调函数
	失败的状态：执行then方法的第二个回调函数
	
	then方法的返回值的promise实例化对象的状态取决于回调函数中的内容
	如果返回为非promise实例化对象，则得到一个是成功的promise
	如果返回的是promise实例化对象，则promise实例化对象的状态和结果值将直接影响result常量的状态和结果值
	如果抛出异常，则新的promise实例化对象（result）为失败的promise
        const p1 = new Promise((resolve,reject)=>{
            resolve('ok');

        })
        const result = p1.then(value =>{
            console.log(value);
        },
        reason=>{
            console.log(reason);
        })
        console.log(result);
```

#### **promise的链式使用**

then方法指定的回调函数执行结果是由其中的内容来决定的

```javascript
const p1 = new Promise((resolve,reject)=>{
            resolve('ok');
        })
        p1.then(value =>{
            console.log(value);
            console.log(1);
        }).then(value =>{
            console.log(2);
        }).then(value=>{
            console.log(3);
        }).then(value=>{
            console.log(4);
        }).then(value=>{
            console.log(5);
        })
```

#### **链式调用之读取文件**

```javascript
const fs = require('fs');
const { resolve } = require('path');
new Promise((resolve,reject) =>{
    fs.readFile('./个人介绍.txt',(err,data) =>{
        if(err) reject(err);
        resolve(data);
    })
}).then(value =>{
    return new Promise((resolve,reject)=>{
            fs.readFile('./111',(err,data) =>{
                if(err) reject(err);
                resolve([value,data]);
            })
        })
    }).then(value =>{
        return new Promise((resolve,reject)=>{
                fs.readFile('./promise.md',(err,data) =>{
                    if(err) reject(err);
                    resolve([value,data]);
                })
            })
        })

```

#### promise封装函数读取文件

```JavaScript
//导入模块
const fs = require('fs');
const { resolve } = require('path');
//封装一个函数
function readFileFun(path){
    return new Promise((resolve,reject)=>{
        fs.readFile(path,(err,data)=>{
            if(err){
                reject(err);
            }else{
                resolve(data);
            }
        })
    })
}
//调用
readFileFun('../个人介绍.txt').then(value=>{
    console.log(value.toString());
},reason=>{
    console.log(reason);
})
```

#### promise.all（）

```html
<!-- 
    promise下的all方法作用主要是针对多个promise的异步任务的处理
    需要接收一个数组类型的参数
    返回值：promise对象，状态也是由数组中的每一个promise对象的状态来决定的
        当所有的promise对象的状态都是成功的，最终的结果就是成功的promise，结果值是由每一个promise的结果值组成的数组
        当所有的promise对象的状态但凡有一个是失败的，最终也是失败的promise，结果值就是失败的这个promise的结果值
-->
    <script>
        const p1 = new Promise((resolve,reject)=>{
            resolve('ok');
        })
        const p2 = new Promise((resolve,reject)=>{
            resolve('yeah');
        })
        const p3 = new Promise((resolve,reject)=>{
            reject('error');
        })

        let result = Promise.all([p1,p2,p3]);
        console.log(result);
    </script>
```

-------模拟接口请求数据

```html
    <script>
       //模拟请求用户列表的数据
       function getUserlist(){
        return new Promise((resolve,reject)=>{
          //定时器模拟异步
          setTimeout(()=>{
            resolve('请求用户列表的数据');
          },1000);
        })
       }
       function getbanlist(){
        return new Promise((resolve,reject)=>{
          //定时器模拟异步
          setTimeout(()=>{
            resolve('请求用户列表的数据');
          },2000);
        })
       }
       //模拟程序启动加载
       function initLoad(){
        let all = Promise.all([getUserlist(),getbanlist()]);
        all.then(value=>{
          console.log(value);
        })
       }
       initLoad();
    </script>
```

#### promise.allSettled()

```html
 <!-- allSettled方法来确定一组异步的操作是否都结束了（不管是成功还是失败）
  其中包含了fulfilled和rejected两种情况 -->
    <script>
      //封装ajax函数
      function ajax(url){
        return new Promise((resolve,reject)=>{
          let xhr = new XMLHttpRequest();
          xhr.open('get',url,true);
          xhr.send();
          xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
              if(xhr.status >= 200 && xhr.status <300){
                resolve(xhr.responseText);
              }else{
                reject(xhr.responseText);
              }
            }
          }
        })
      }
      Promise.allSettled([
        ajax('http://iwenwiki.com/api/blueberrypai/getChengpinInfo.php'),//里面放路径
        ajax('http://iwenwiki.com/api/blueberrypai/getListeningInfo.php')
      ]).then(value =>{
        let successList = value.filter(item=>item.status === 'fulfilled');
        console.log(successList);
        let errorList = value.filter(item=>item.status === 'rejected');
        console.log(errorList);
      }).catch(reason=>{
        console.log(reason);
      })
    </script>
```

#### Promise.any()

```html
<!--
Promise下的any方法，只要参数有一个Promise实例化对象的状态为fulfilled,则整体结果为fulfilled
如果所有的promise实例都是rejected，那么结果就是rejected
-->
<script>
	 	let p1 = new Promise((resolve,reject)=>{
            resolve('ok');
        })
        let p2 = new Promise((resolve,reject)=>{
            resolve('yeah');
        })
        let p3 = new Promise((resolve,reject)=>{
            reject('error');
        })

        let result = Promise.any([p1,p2,p3]);
        console.log(result);
</script>
```

#### Promise.race()

```html
<!--
promise.race方法是需要传递一个参数，参数为数组，数组中的内容表示的是promise实例化对象
如果有最先到达状态的（pending来更改成fulfilled或者是rejected）,
不管是成功状态还是失败的状态，都将以这个对象的状态和结果值为准 
-->
<script>
	 	const p1 = new Promise((resolve,reject)=>{
            resolve('ok');
        })
        const p2 = new Promise((resolve,reject)=>{
            reject('yeah');
        })
        const p3 = new Promise((resolve,reject)=>{
            resolve('error');
        })

        let result = Promise.race([p1,p2,p3]);
        console.log(result);
</script>
```

#### Promise.reject()

​	promise.reject方法将始终返回一个为失败的promise对象

​	无论参数是否为Promise还是其他，最终都将返回失败的Promise

#### Promise.resolve()

​	promise.resolve方法：将一个普通的值转换为Promise类型的数据

​	分两种情况：

1. 当esolve方法参数为非promise对象，则返回的结果为成功的promise对象
2. 当resolve方法参数为promise对象，则参数对象的状态和结果将直接影响最终resolve方法的返回值的那个对象的状态和结果（成功--成功；失败---失败）

#### Promise.catch()

```html
<!--
then方法中传入两个参数，当然也可以不传递，也可以只传递成功的回调函数
也可以单独的来使用catch专门指定失败的回调函数
catch方法也有返回值，和then的方法返回值类似
catch返回一个Promise实例化对象
for example：若是失败函数中没有返回值，则得到一个成功的Peomise实例化对象，结果为undefined；
若是失败的函数中有返回值，且这个返回值不是Promise实例的情况下，新的promise对象的状态和结果值完全取决于返回的promise对象的状态以及结果值
-->
<script>
const p1 = new Promise((resolve,reject)=>{
            resolve('ok');
        })
        p1.catch(reason=>{
          console.log(reason);
        })
     //与then方法结合
        //异常/错误 穿透
        //当执行多个成功的回调函数，最后一次使用catch
        //当实例化对象为rejected,则会一直向下穿透catch方法
        p1.catch(reason=>{
          console.log(reason);
        })
        p1.then(value =>{
          console.log(value);
        }).then(value=>{
          console.log(value);
        }).catch(resaon=>{
          console.log(reason);
        })
</script>
```

#### promise.finally()

```
是ES9新增的特性，表示无论promise对象变成了fulfilled还是rejected状态，最终都会执行
finally方法的回调函数的参数是不接受参数的
```

#### 终止promise链条

```JavaScript
    <script>
	 	new Promise((resolve,reject)=>{
      resolve(1);
    }).then(value=>{
      console.log(value);
    }).then(value=>{
      console.log(222);
    }).then(value=>{
      console.log(333);
      return new Promise((resolve, reject) => {
      })
      //return false
      //throw 异常
      //终止链条主要是为了返回一个pending状态的promise实例化对象
      //
    }).then(value=>{
      console.log(4444);
    }).catch(reason=>{
      console.log(reason);
    })
    </script>
```

#####  eg1:一个promise实例化对象指定多个成功/失败的回调函数，都会进行调用吗？			

一定会执行，但是前提是promise对象的状态已经更改成了成功/失败，但是不能是pending

##### eg2:改变promise状态和指定回调函数执行，谁先谁后

若执行器函数中为同步函数，先修改状态，后指定回调

若执行器函数中为异步任务，先指定回调，再更改状态（promise主要是为了执行异步任务）

#### async函数

1. 任何函数都可以被声明为一个async函数
2. 实现的功能就是异步功能（定时器，ajax请求）
3. 要将实现的功能封装到一个函数之中，在函数的前面添加一个async

ansyc函数返回

eg1:返回非promise对象的数据

eg2:返回的是promise对象，这个对象将直接影响结果产生的promise实例化对象的状态和结果值

eg3:抛出异常

#### await表达式

1. 在函数内部执行异步的功能，并得到成功的结果数据值
2. async函数中不一定要完全结合await；但是有await的函数一定是async函数
3. await相当于then，可以直接拿到成功的promise实例化对象的结果值
4. await表达式后面是promise实例化对象，则await返回的是promise的成功的结果值
5. 如果await表达式后面的是其他值，则这个其他值作为await的返回值

```JavaScript
   <script>
	 async function main(){
    let rs = await 100;
    console.log(rs);
   }
   main();
    </script>
```

#### await表达式的执行顺序

**如果有同步代码和异步代码同时出现，一定是先执行同步代码，再执行异步代码**

#### 宏队列和微队列

DOM时间管理模块 + Ajax回调管理模块 + 定时器管理模块  } ===== > 宏队列

==========>  dom时间回调  ， Ajax回调   ， 定时器回调

promise管理模块 +  Mutation回调管理模块 } =========>  微队列  =======> promise回调  ，  mutation回调

**同（输入输出，for循环之类）  微  宏**

# three:dos攻击

拒绝服务攻击  ---  这种类型的网络攻击使用**远程计算机**向选定的服务器发送 **UDP 和 TCP 数据包**。发生这种攻击时，所有服务都会关闭。这是因为通过网络泛滥的数据包使服务器的能力超载。正因为如此，整个受到攻击的网络中的其他用户和设备都无法使用该服务器。

### **缓冲区溢出攻击**

这是最常见的 DoS 攻击。在缓冲区溢出攻击下，网络攻击者使网络地址超载“流量”，从而使网络无法使用。

### **Ping of Death 或 ICMP Flood**

这种类型的攻击利用配置错误或未配置的网络设备。它使用它们来发送欺骗数据包，这些数据包会对网络上的每台计算机进行 ping 操作。

这就是它通常被称为 Ping of Death (POD) 攻击的原因。

### **同步洪水**

这些攻击向服务器发送网络连接请求，然后不完成该过程。然后，网络会被连接请求的轰炸淹没，这将不允许真正的用户连接到网络。

### **泪珠攻击**

当发生泪滴式 DoS 攻击时，攻击会将 IP 数据包片段直接发送到网络。然后，网络尝试将数据包片段重新编译为原始数据包。

运行此过程时，系统会耗尽并崩溃。这是因为数据包中的字段是为了混淆服务器，因为它们不可能放回原处。

# script 标签的 defer 和 async 属性

<script>
遇到script 暂停文档解析-----开始加载script ，加载完成后执行js代码
</script>


<script async>
异步加载script 加载完成后执行JS代码  ---- 加载script完成后暂停解析HTML   
</script>


<script defer>
浏览器渲染线程在解析HTML文档，遇到script标签，异步加载script
HTML完成解析之后执行JS代码    
</script>


- `defer`、`async`只对外联`script`脚本文件有效, 内联`script`脚本设置无效；
- 加上`async`或`defer`的`js`脚本（如果不考虑兼容性），放在`HTML`头部可以减少网页的下载加载时间，优化页面加载的性能；
- 若`defer`和`async`属性同时存在，则`async`起作用；

# display：none 与 visibility：hidden 的区别

dispaly:none 设置该属性后，该元素下的元素都会隐藏，占据的空间消失 

visibility:hidden 设置该元素后，元素虽然不可见了，但是依然占据空间的位置

##### 区别

1.visibility 具有继承性，其子元素也会继承此属性，若设置 visibility:visible， 则子元 素会显示

2.visibility 不会影响计数器的计算，虽然隐藏掉了，但是计数器依然继续运行着。

3.在 CSS3 的 transition 中支持 visibility 属性，但是不支持 display，因为 transition 可以延迟执行，因此配合 visibility 使用纯 CSS 实现 hover 延时显示效果可以 提高用户体验

4.display:none 会引起回流(重排)和重绘 visibility:hidden 会引起重绘

# a标签创建下载链接

HTML的a标签可以创建一个下载链接，有以下几种方法：

- 在a标签中添加 download 属性，这样点击链接时就会下载超链接目标，而不是打开它¹。例如：

```html
<a href="/images/myw3schoolimage.jpg" download="w3logo">点击下载图片</a>
```

- 在a标签中添加 download 属性，并设置一个值来指定下载文件的名称。例如：

```html
<a href="/images/myw3schoolimage.jpg" download="mylogo.jpg">点击下载图片</a>
```

- 在后端设置 Content-Disposition 响应头，来告诉浏览器以附件的形式下载文件。例如：

```php
<?php
// 设置文件名
$filename = "mylogo.jpg";
// 设置响应头
header("Content-Disposition: attachment; filename=$filename");
// 读取文件内容并输出
readfile("/images/myw3schoolimage.jpg");
?>
```

- 使用 URL.createObjectURL() 方法，来创建一个指向文件对象的 URL，并把它赋给 a 标签的 href 属性。例如：

```javascript
// 获取文件对象
var file = document.getElementById("file").files[0];
// 创建 URL
var url = URL.createObjectURL(file);
// 获取 a 标签
var link = document.getElementById("link");
// 设置 href 属性
link.href = url;
// 设置 download 属性
link.download = file.name;
```

# var - let - const 区别

## var

- var 在全局作用域定义时，还会挂载到window（浏览器环境）上，生成全局变量
- 可以重复声明，**后面申明覆盖前面声明**
- 存在变量提升（自动把声明提到作用域顶部），不规范写法，易导致可读性差

## let

- 除了全局作用域和函数作用域外，还新增了块级作用域（ { } ）
- 不能重复声明
- 作用域内，声明语句前使用会报错（暂时性死区 temporal dead zone TDZ）

## const

- let 基础上，规定了申明后不可修改，**用于声明常量**，**不可以改变数据**
- 声明后不可修改，必须声明时候赋值
- 如果声明的是引用类型，保存的是引用地址，所以不能重新赋值，但是可以修改引用对象内部的属性

# option

浏览器的请求基本上都是跨域请求（ip/端口/协议不可能完全相同），前后端分离，跨域请求需要浏览器和服务器同时支持

#### 跨域限制的原因是因为：

浏览器为了保证网页的安全，出的同源协议策略

#### 跨域解决方案

cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

#### node中间件、nginx反向代理：

跨域限制的时候浏览器不能跨域访问服务器，**node中间件和nginx反向代理，都是让请求发给代理服务器**，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，**服务器和服务器之间不存在同源限制**。

**JSONP：**

利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。

缺点：只支持get数据请求，不支持post数据请求;与ajax之间没有关系，没有用到xmlhttpRequest对象

实现：

1. 定义一个回调函数success

<script>
	function success(data){
        console.log("获取到数据");
        console.log(data)
    }
</script>


2. 通过script标签，请求接口数据

<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=silly&sge=20"></script>

#### postmessage：

H5新增API，通过发送和接收API实现跨域通信。



跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法 （特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求）， 浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request）， 从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。

```html
// 引入 import qs from 'qs' // 然后在请求拦截器的部分 axios.interceptors.request.use((config) => {  if(config.method  === 'post'){    config.data = qs.stringify(config.data);  }  return config; },(error) =>{  return Promise.reject(error); }); 
```

```
 // qs.stringify 前 
 config.data = {    
 "userId": "520b0ec3229",     "startTime": "15489504",     "endTime": "1559999" } // qs.stringify 后,内容变为 "userId=520b0ec3229&startTime=15489504&endTime=1559999"
```



## 说一说JS实现异步的方法？

 所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。

 回调函数是异步操作最基本的方法，比如AJAX回调，

回调函数的优点是简单、容易理解和实现，

缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

此外它不能使用 try catch 捕获错误，不能直接 return Promise包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve 和 reject方法，then接收到对应的数据，做出相应的处理。

Promise不仅能够捕获错误，而且也很好地解决了回调地狱的问题，缺点是无法取消 Promise，错误需要通过回调函数捕获。 

Generator 函数是 ES6 提供的一种异步编程解决方案，Generator 函数是一个状态机，封装了多个内部状态，可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。

优点是异步语义清晰，缺点是手动迭代`Generator` 函数很麻烦，实现逻辑有点绕 async/awt是基于Promise实现的，async/awt使得异步代码看起来像同步代码，所以优点是，使用方法清晰明了，缺点是awt 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 awt 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。

#####  JS 异步编程进化史：

callback -> promise -> generator/yield -> async/awt。 async/awt函数对 Generator 函数的改进，体现在以下三点： - 内置执行器。 Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 - 更广的适用性。 yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 awt 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 - 更好的语义。 async 和 awt，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，awt 表示紧跟在后面的表达式需要等待结果。 目前使用很广泛的就是promise和async/awt

# 创建ajax过程？

1. 创建XHR对象：new XMLHttpRequest()

2.   设置请求参数：request.open(Method, 服务器接口地址); 

3. 发送请求: request.send()，如果是get请求不需要参数，post请求需要参数request.send(data)

4. 监听请求成功后的状态变化：根据状态码进行相应的处理。 

   ```java
   XHR.onreadystatechange = function () { if (XHR.readyState == 4 && XHR.status == 200) { console.log(XHR.responseText); // 主动释放,JS本身也会回收的 XHR = null; } }; 
   ```

   **加分回答**

   POST请求需要设置请求头 readyState值说明 0：初始化,XHR对象已经创建,还未执行open

    1：载入,已经调用open方法,但是还没发送请求

    2：载入完成,请求已经发送完成

    3：交互,可以接收到部分数据

    4：数据全部返回 status值说明 200：成功 404：没有发现文件、查询或URl 500：服务器产生内部错误

# cookie sessionStorage localStorage 区别？

得分点 数据存储位置、生命周期、存储大小、写入方式、数据共享、发送请求时是否携带、应用场景 标准回答 Cookie、SessionStorage、 LocalStorage都是浏览器的本地存储。

 它们的共同点：都是存储在浏览器本地的 

它们的区别：cookie是由服务器端写入的，SessionStorage、 LocalStorage都是由前端写入的，

cookie的生命周期是由服务器端在写入的时候就设置好的，

LocalStorage是写入就一直存在，除非手动清除，SessionStorage是页面关闭的时候就会自动清除。

cookie的存储空间比较小大概4KB，SessionStorage、 LocalStorage存储空间比较大，大概5M。

Cookie、SessionStorage、 LocalStorage数据共享都遵循同源原则，SessionStorage还限制必须是同一个页面。在前端给后端发送请求的时候会自动携带Cookie中的数据，但是SessionStorage、 LocalStorage不会 加分回答 由于它们的以上区别，所以它们的应用场景也不同，Cookie一般用于存储登录验证信息SessionID或者token，LocalStorage常用于存储不易变动的数据，减轻服务器的压力，SessionStorage可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能

# 样式优先级的规则是什么？

`!important`、行内样式、嵌入样式、外链样式、id选择器、类选择器、标签选择器、复合选择器、通配符、继承样式 

# 说一说 Vue 中 $nextTick 作用与原理？

得分点 异步渲染、获取DOM、Promise

 标准回答 **Vue 在更新 DOM 时是异步执行的**，在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。 

$nextTick的作用是：该方法中的代码会在当前渲染完成后执行，就解决了异步渲染获取不到更新后DOM的问题了。 $nextTick的原理：$nextTick本质是返回一个Promise 

加分回答 应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中

# v-if 和 v-show区别？

得分点 v-show true/false都渲染 、 v-if true渲染 false不渲染

 标准回答 作用: 都是控制元素隐藏和显示的指令 

区别： v-show: 控制的元素无论是true还是false，都被渲染出来了，通过display：none控制元素隐藏 

v-if: 控制的元素是true，进行渲染，如果是false不渲染，根本在dom树结构中不显示 

应用： v-show: 适合使用在切换频繁显示/隐藏的元素上

 v-if: 适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上



# pc端开发不同屏幕分辨率的适配问题如何解决？

1. rem或者百分比，媒体查询可以设置不同屏幕尺寸下的网页端布局样式，rem实现页面元素的动态缩放（移动端）
2. 也可以使用组件库，组件库自带栅格系统





webpack:



api:





- mock.js
  three.js
  echarts
  Moment.js
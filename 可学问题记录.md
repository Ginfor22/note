# 项目历程记录

## 初始化

### npm install 报错：

	4 packages are looking for funding  run `npm fund` for details

解决：npm fund 

![image-20230710195737565](C:\Users\lemon\AppData\Roaming\Typora\typora-user-images\image-20230710195737565.png)

然后再运行 yarn install   显示success （第一次运行的是npm install  发现依旧提示 npm   fund ）

同理，在vite项目中按需引入组件的时候，使用npm 会提示捐赠者信息；但是使用yarn 就不会显示

同理在使用npm 安装vant 依旧会出现这个情况  ，于是使用yarn add vant 命令行



npm run dev  报错：import styleImport from 'vite-plugin-style-import'

但是在vite.config.ts里面是手动引入了import依赖

尝试使用    添加import {VantResolver} from "unplugin-vue-components/resolvers";以及补充lib，不然会报错找不到ts里面的东西

> ```typescript
> import { defineConfig } from 'vite'
> // @ts-ignore
> import vue from '@vitejs/plugin-vue';
> import styleImport, { VantResolve } from 'vite-plugin-style-import';
> import {VantResolver} from "unplugin-vue-components/resolvers";
> 
> // https://vitejs.dev/config/
> export default defineConfig({
>   plugins:
>       [vue(),
>         styleImport({
>     resolves:[VantResolver()],
>             libs: [
>                 {
>                     libraryName: 'vant',
>                     esModule: true,
>                     resolveStyle: name => `../es/${name}/style`
>                 }
>             ]
> 
> ​        })]
> })
> ```



### 数据库

备注：

1. MySQL 中不存在专门的布尔类型，实际存储数据时，对于布尔值，在数据库中的存储类型就是 tinyint
2. tinyint是一种非常小的整数，在 MySQL 中，tinyint 类型在有符号（signed）时允许存储从 -128 到 127 的整数，在无符号（unsigned）情况时允许存储从 0 到 255 的整数，实际占用空间为 1 个字节。
3. tinyint(1)，此类型被 MySQL 默认用于表示布尔值，0代表false，1代表true





### SQL语言分类：

DDL define 建表，操作表

DML  manage  更新删除数据，影响实际表里的内容

DCL control  控制，权限

DQL query 查询 select

### 用户表设计

### 设计用户表

用户表基础上设计标签

查询所有标签，将标签分组？------按父标签id分组，实现

根据父标签查询子标签？根据id查询，实现

根据标签筛选用户，需要建立一个标签表（分类）

### 设计标签表

字段：

id int 主键

标签名 varchar 非空（必须唯一，唯一索引）

上传标签的用户 userId int（如果要根据 userId 查已上传标签的话，最好加上，普通索引）

父标签 id ，parentId，int（分类）

是否为父标签 isParent, tinyint（0 不是父标签、1 - 父标签）

创建时间 createTime，datetime

更新时间 updateTime，datetime

是否删除 isDelete， tinyint（0、1）

### 修改用户表

用户有哪些标签？

1. 直接在用户表补充tags字段，JSON字符串['name','age']

   优点：查询方便，不用新建关联表

2. 加一个关联表，记录用户和标签的关系

   关联表的应用场景：查询灵活，可以正差反查

   缺点：多建一个表，多维护一个表







# 简历项目整理

## 伙伴匹配系统

涉及到知识点：



### **如何在项目中进行数据的返回的？**

定义一个通用返回类，配合异常处理器使用，在其中定义错误码，具体错误信息，错误信息描述等内容，再分别定义一个类的多个方法来返回不同情况的信息，实现统一封装，避免暴露给客户端信息

#### 数据库表的设计

##### **你是如何确定数据库表结构的？你采用了哪些建表原则和规范？**

首先确定系统针对的用户，既然有创建伙伴和寻找伙伴的需求，就需要设计一个用户表，想要实现搜索，就还需要给每个用户上标签，上了标签之后需要标签表，同时因为用户和队伍是多对多的关系需要设计一个用户和队伍的关系表，这就是数据库的表结构。

**建表原则和规范**

\1. 主键和自增长：每张表都设置了一个主键，并使用了`auto_increment`实现自增长。

\2. 数据类型：对于每个字段都选择了合适的数据类型，如`varchar`、`int`、`datetime`等。

\3. 注释：每个表和字段都添加了注释，方便其他人阅读和理解。

##### 数据方法 flat和flatMap

- flat 按照一个可以指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。返回值是一个包含将数组与子数组中所有元素的新数组，并不改变原有数组

`var newArray = arr.flat([depth])`  

depth:指定要提取嵌套数组的结构深度，默认值为1

- flatMap 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组

​		返回值是一个新数组，其中每个元素都是回调函数的结果，并且结构深度depth值为1，不改变原数组 

​	callback：可以生成一个新数组中的元素的函数，可以传入三个参数

​	index：可选，数组中正在处理的当前元素的索引

​	currentVlaue：当前数组中处理的元素

​	array：可选，被调用的map数组

​	thisArg：可选，执行callback函数使用的this值



```vue
var new_array = arr.flatMap(vue
function callback(currentValue[,index[,array]]){
//return element for new_array
}[,thisArg])
```

- ​	flatMap方法与Map方法和深度depth为1 的flat几乎相同

- map:

  ```javascript
  var arr= [1,2,3];
  var arg = arr.map(x=>[x*2]);
  console.log(arg)
  console.log(arr)
  ```

  

标签的选择，过滤

###### first:

这个过滤方法改变了tagList，从一个对象，嵌套数组，变为了一个数组

![image-20230908160902956](C:\Users\lemon\AppData\Roaming\Typora\typora-user-images\image-20230908160902956.png)

###### second:

```vue
const onSearch = (val)=>{
tagList.value = tagList . flatMap(parentTag.children).filter(item=>item.text.includes(searchText.value));
}
```

###### third:

过滤的时候最好设置一个原数组（保证原始数组不被改变），利用flatMap每次过滤导致数组变少，使用ES6新语法：const temChildren = [...parentTag.children];

```vue
const onSearch = (val) => {List.value = originTagList.map(parentTag => {
  const tempChildren = [...parentTag.children];
  const tempParentTag = {...parentTag};
  tempParentTag.children = tempChildren.filter(item => item.text.includes(searchText.value));
  return tempParentTag;
  });

}
```

##### 请介绍一下Redis分布式Session的实现方式

因为Session只在同一个服务器上储存，Redis分布式Session，是通过将Session信息存储到Redis中实现的Session共享方案，让其他服务器也能拥有Session信息，它可以有效解决分布式系统中Session共享的问题。

**Redis缓存的使用是为了解决高并发访问下数据库读写压力过大的问题，提高系统的性能和响应速度。下面是使用Redis缓存的好处和需要注意的问题：**

Redis缓存的使用是为了解决高并发访问下数据库读写压力过大的问题，提高系统的性能和响应速度。下面是使用Redis缓存的好处和需要注意的问题：

好处：

\1. 提高性能和响应速度：Redis缓存使用内存进行数据存储，读写速度非常快，能够大大减少数据库的读写次数，提高系统的性能和响应速度。

\2. 缓解数据库压力：Redis缓存可以将热点数据缓存到内存中，减少数据库的读写压力，防止出现数据库瓶颈。

\3. 减少网络传输开销：Redis缓存位于应用层和数据库之间，可以缓存需要频繁查询的数据，避免频繁地进行网络传输，减少网络传输开销。

需要注意的问题：

\1. 缓存数据一致性问题：使用Redis缓存需要注意缓存数据和数据库数据的一致性问题，缓存数据的更新需要与数据库数据同步更新，避免出现数据不一致的情况。

\2. 缓存雪崩问题：当缓存中的数据过期或失效时，如果大量请求同时访问数据库，会导致数据库压力剧增，进而引起系统崩溃。为了避免这种情况的发生，可以采用分布式锁、缓存预热等方式进行缓解。

\3. 缓存穿透问题：当访问一个不存在的数据时，会导致缓存和数据库都无法命中，进而导致频繁地进行数据库查询，引起数据库压力剧增。为了避免这种情况的发生，可以采用布隆过滤器、缓存空对象等方式进行缓解。

\4. 缓存击穿问题：当一个热点数据过期或失效时，大量请求同时访问该数据，会导致缓存和数据库都无法命中，进而引起数据库压力剧增。为了避免这种情况的发生，可以采用分布式锁、缓存预热等方式进行缓解。

##### Vue3中的onMounted

钩子函数会在组件挂载到 DOM 后运行，通常用于获取数据和初始化页面状态等操作。

*在 Vue 3 中，`onMounted` 和 `onBeforeMount` 钩子需要在 `setup` 函数中使用。*

##### 组件---setup:

`setup` 函数是一个全新的组件选项。它是 Composition API 的核心，用于初始化组件实例。

`setup` 函数接收两个参数：`props` 和 `context`。其中 `props` 是父组件传递给当前组件实例的属性，而 `context` 则包含了一些 helper 方法和组件选项（如 `attrs`、`slots` 和 `emit` 等）。

在 `setup` 中，我们可以使用 Vue 3 提供的多个工具函数来定义响应式数据、监听生命周期钩子、处理计算属性、声明事件处理函数等。这些函数包括：

- `reactive`：用于创建响应式对象

- `ref`：用于创建一个单一的响应式值

- `computed`：用于创建计算属性

- `watch`：用于监听响应式数据的变化

- `onMounted`、`onUpdated` 和 `onUnmounted`：用于监听生命周期钩子

- `toRefs`：用于将响应式对象转换为普通对象

- `inject` 和 `provide`：用于跨层级组件传递数据

- `getCurrentInstance`：用于访问当前组件实例

  

##### 扩展补充：vue生命周期



### 数据的传输：

来自后端的接口，对数据（参数名称，参数值） 进行判断，利用apifox检查接口数据是否正常，再前端利用axios（属于插件plugins）整合，get请求--->搜索结果页面

搜索结果，vant框架辅助开发，对userList进行判断，定义路由跳转对象，挂载mounted函数，异步执行，用axios定义接口，获取数据库中的数据；在最后判断拿到的数据是否存在，将数据进行遍历循环，对user拿到的数据进行json解析。最后用value显示

#### 前端没有写editKey，修改信息报错----->

#### todo补充校验，如果用户没有传任何要更新的值，就直接报错 ，不用执行更新语句

​	没有更新内容，后端在拼接的时候出现问题。后端需要限制前端的传参

​	获取当前用户信息，写一个路由的钩子，每切换一个页面，获取信息一次；也可以使用缓存

#### 接口问题：

​	根据不同的角色，写不同的更新接口，那么前端的请求都是通过一个请求提交请求，	怎么设置不同的接口？

​	两个应用请求不同的接口，看应用受众人群，node中间层，区分请求的接口

#### **useRoute()**

​	route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等：

matched: 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象

name: 当前路径的名字，如果没有使用具名路径，则名字为空。

params: 对象，包含路由中的动态片段和全匹配片段的键值对

path: 字符串，等于当前路由对象的路径，会被解析为绝对路径，如 “/home/news”

query: 对象，包含路由中查询参数的键值对。 例如，对于 /home/news/detail/01?favorite=yes ，会得到$route.query.favorite => ‘yes’

```javascript
//myaxios.js  插件
import axios, {AxiosInstance} from "axios";

const isDev = process.env.NODE_ENV === 'development';

const myAxios: AxiosInstance = axios.create({
    baseURL: isDev ? 'http://localhost:8080/api' : '线上地址',
});

myAxios.defaults.withCredentials = true; // 配置为true

// Add a request interceptor
myAxios.interceptors.request.use(function (config) {
    console.log('我要发请求啦', config)
    // Do something before request is sent
    return config;
}, function (error) {
    // Do something with request error
    return Promise.reject(error);
});

// Add a response interceptor
myAxios.interceptors.response.use(function (response) {
    console.log('我收到你的响应啦', response)
    // 未登录则跳转到登录页
    if (response?.data?.code === 40100) {
        const redirectUrl = window.location.href;
        window.location.href = '/user/login?redirect=${redirectUrl}';
    }
    // Do something with response data
    return response.data;
}, function (error) {
    // Do something with response error
    return Promise.reject(error);
});

export default myAxios;

```

get请求--->搜索结果页面

```JavaScript
//搜索结果页面，挂载onmounted
const {tags} = soute.query;
onMounted(()=>{
myAxios.get('/user/search/tags',{
params:{
tagNameList:tags
},
paramsSerializer:params=>{
return qs.stringify(params,{indices:false})
}
})
.then(function(response){
console.log('/user/search/tags succeed',response);
Toast.success('请求成功')
})
.catch(function(error){
console.log('/user/search/tags error',error);
Toast.error('请求失败')
})
console.log(userListData)
    if(userListData){
        if(user.tags){
            userListData.forEach(user=>{
                if(user.tags){
                    //json转换为数组
                    user.tags = JSON.parse(user.tags);
                }
            })
            userList.value = userListData;
        }
    }
})
```

#### 出现传参问题：

​	前端读取数据失败，他接受到了taglist，但是不会解析，于是需要需要将数据序列化，[qs](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fljharb%2Fqs)是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object，而且支持复杂的嵌套。

在Axios中使用：使用示例

```JavaScript
  // 请求拦截器
  service.interceptors.request.use(
    (config: AxiosRequestConfig) => {
      const { method, data, headers } = config
      removePending(config)
      cancel.cancel_request && addPending(config)

      if (['post', 'put', 'delete'].includes(method as string)) {
        config.data = qs.parse(data) //序列化,将查询字符串解析为对象
      }
      return config
    },
    error => {
      message.error(error.data.error.message)
      return Promise.reject(error.data.error.message)
    }
  )
```



#### 出现跨域问题

​	前端3000，后端8080：

在后端加一个注解，SpingBoot:里面有一个@CrossOrigin(origins={"http://localhost:3000"})  //只能防止前端的攻击，使用Java请求的话也是可以获取你的接口



**去看用户中心做笔记解决跨域问题**



#### 根据环境更换URL

**在用户中心做笔记**





#### 获取用户信息



#### 后台接口更新用户信息：

前端页面修改数据不变化时，后台需要在control加一个接口

1. 检验参数是否为空

2. 效验权限

3. 触发更新

   ![image-20230911125957114](C:\Users\lemon\AppData\Roaming\Typora\typora-user-images\image-20230911125957114.png)

### Session 共享

种 session 的时候注意范围，cookie.domain

eg:用户在 A 登录，所以 session（用户登录信息）存在了 A 上

结果请求 B 时，B 没有用户信息，所以不认识。

比如两个域名：

aaa.yupi.com

bbb.yupi.com

如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com

解决方案：**共享存储** ，而不是把数据放到单台服务器的内存中

如何共享存储？

1. Redis（基于内存的 K / V 数据库）此处选择 Redis，因为用户信息读取 / 是否登录的判断极其**频繁** ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w
2. MySQL 
3. 文件服务器 ceph





### 区分点：router.replace  ----- router.push

##### push:

1. 跳转到指定URL，向history栈添加一个新的记录，**点击后退会返回至上一个页面**

2. 声明式<router-link :to="....">

    编程式: router.push(...)//该方法的参数可以是一个字符串路径，或者一个描述地址的对象。

##### replace:

1. 跳转到指定URL，**替换history栈中最后一个记录**，点击后退会返回至上上一个页面(A----->B----->C  结果B被C替换  A----->C)
2. 设置 replace 属性（默认值: false）的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。即使点击返回按钮也不会回到这个页面加上replace: true后，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。

***两者都可以传递参数，区别是什么？***

```vue
query: 
    this.$router.push({
      path: '/home',
      query: {
        site: [],
        bu: []
      }
    })
params:
  this.$router.push({
    name: 'Home',  // 路由的名称
    params: {
      site: [],
      bu: []
    }
  })
params：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params
query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。
```

query 传参配置的是path，而params传参配置的是name，在params中配置path无效

query在路由配置不需要设置参数，而params必须设置

query传递的参数会显示在地址栏中

params传参刷新会无效，但是query会保存传递过来的值，刷新不变 ;

1.命名路由搭配params，刷新页面参数会丢失

2.查询参数搭配query，刷新页面数据不会丢失

3.接收参数使用this.$router后面就是搭配路由的名称就能获取到参数的值

#### hash与history

1. 一般的需求场景中，hash模式与history模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势：
2.  pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url
3. pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中 
4. pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串

history模式解决方案：

官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果`URL`匹配不到任何静态资源，则应该返回同一个`index.html`页面，这个页面就是你`app`依赖的页面。同时这么做以后，服务器就不再返回`404`错误页面，因为对于所有路径都会返回`index.html`文件。为了避免这种情况，在`Vue`应用里面覆盖所有的路由情况，然后在给出一个`404`页面。或者，如果是用`Node.js`作后台，可以使用服务端的路由来匹配`URL`，当没有匹配到路由的时候返回`404`，从而实现`fallback`。

#### cookie没有存储在浏览器内：

当前端后端的域名不一样，解决了跨域，但是cookie没有出现 （浏览器缓存先清理一下）    ----->原因：axios没有携带请求的凭证

```typescript
`myAxios.default.withCredentials=true`
```

#### 向前端获取信息方法

前端设计一个api, userpage在userapi里面调用

```typescript
import myAxios from "../plugins/myAxios";
import { setCurrentUserState } from "../states/user";

export const getCurrentUser = async () => {
    // const currentUser = getCurrentUserState();
    // if (currentUser) {
    //     return currentUser;
    // }
    // 不存在则从远程获取
    const res = await myAxios.get('/user/current');
    if (res.code === 0) {
        setCurrentUserState(res.data);
        return res.data;
    }
    return null;
}

```

## 面试问题：

1. 项目前端使用了 Vant UI 组件库，请列举几个你用到的 Vant UI 组件并介绍它们的用途？
2. 如何基于 Vue Router 实现动态切换导航栏标题？请详细描述一下实现的过程。
3. 什么是前端异步编程？请介绍一下 Promise、async/await 在 JavaScript 中的作用及用法。
4. 请介绍一下 Vue 3 的新特性和与 Vue 2 相比有哪些变化？
5. 移动端网站和响应式网站有什么区别？你在项目中是如何处理移动端适配的？
6. Vue.js 中的组件通信方式有哪些？
7. 在你的项目中，为什么选择了全局通用的 Layout 组件而不是局部组件？
8. 你是如何初始化项目的？是否有使用脚手架？
9. 你在前端项目中有做过性能优化吗？请分享一些常见的性能优化措施和实践经验。
10. 你在项目中使用了 Vue Router 全局路由守卫，请解释一下路由守卫的概念和用法，并介绍一下它在你项目中的实际应用场景？

### 请介绍一下你在项目中使用的 Redis，它有哪些优势，为什么选择使用 Redis 实现分布式 Session？

redis优势：Redis以其高性能、灵活的数据模型和丰富的功能成为了一个受欢迎的键值存储系统，适用于许多场景和应用程序。

选用Redis实现分布式Session：使用Redis实现分布式Session可以获得高性能、可靠性和可扩展性的优势，有效地管理和存储Session数据。它成为了许多大型Web应用程序和系统的首选方案。

如何实现的：

在开发中把用户的登录信息存储在session里。而session是依赖于cookie的，即服务器创建session时会给它分配一个唯一的ID，并且在响应时创建一个cookie用于存储这个SESSIONID。当客户端收到这个cookie之后，就会自动保存这个SESSIONID，并且在下次访问时自动携带这个SESSIONID，届时服务器就可以通过这个SESSIONID得到与之对应的session，从而识别用户的身。

### 你在用户登录功能中提到使用 Hash 代替 String 存储用户信息，这样的做法有什么好处？在实际应用中，Hash 与 String 存储方式有哪些区别？

好处：

安全性：哈希是不可逆的，意味着无法从哈希值推导出原始数据。

防止碰撞：哈希算法通常具有较低的碰撞概率，即不同的输入对应的哈希值应尽量不相同。

验证一致性：当用户登录时，系统可以将用户输入的密码进行哈希，与数据库中存储的哈希进行比较。

区别：使用哈希存储用户信息可以提高数据安全性并防止密码泄露，但同时也会牺牲数据的可逆性和直接读取的能力。










